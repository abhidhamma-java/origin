---
title: 최대공약수와 최소공배수
date: '2022-01-28'
tags: ['algorithm', 'math']
draft: false
summary: 최대공약수와 최소공배수
---

최대공약수와 최소공배수는 GCD(a, b)  
를 통해 구할 수 있다.

# GCD(최대공약수)

GCD(Greatest Common Divisor)는  
그 자체로 최대공약수이다.

# LCM(최소공배수)

LCM(Least Common Multiple)은  
a \* b / GCD를 통해 구할 수 있다.

```java
// 반복문 방식
int gcd(int a, int b) {

	while(b != 0) {
		int r = a % b;
		a = b;
		b = r;
	}
	return a;
}

// 재귀 방식
int gcd(int a, int b) {
	if(b == 0) return a;
	return gcd(a, a % b);
}

// 최소공배수 : Least Common mulitple
int lcm(int a, int b) {
	return a * b / gcd(a, b);
}
```

---

## 설명

원래는 A와 B 두 수가 주어지면  
A의 약수를 모두 구하고,  
B의 약수를 모두 구한뒤  
공통된 약수들을 찾아서  
찾은 약수들의 곱으로 나타내준다.

라고 배웠었는데  
이 방법은 숫자가 커지고 약수가 많아지면  
연산이 많아지고 느려진다.

위 코드의 방법은 유클리드호제법이라고 한다.  
원래 여러 조건이 있지만  
단순화한 유클리드 호제법의 방법은 이렇다.

> A와 B가 있을때
>
> A와 B중에 큰수를 작은수로 나눈 나머지를  
> R이라고 할때
>
> A와 B중 작은 수와 R의 최대공약수가  
> 같다는 성질을 이용한것이다.
>
> 즉 GCD(A, B) = GCD(B, R)인것이다
> 이 성질을 계속 사용해보면  
> 결국 최대공약수가 만들어진다.

ex) 581과 322의 최대공약수와 최소공배수 구하기

최대공약수  
GCD(581, 322), r = 259  
GCD(322, 259), r = 63  
GCD(259, 63), r = 7  
GCD(63, 7) => 7이 소수니까 최대공약수는 7이다.

최소공배수  
최소공배수는 서로소인 두 수와 최대공약수의 곱인데  
A는 서로소 a _ 최대공약수 d,  
B는 서로소 b _ 최대공약수 d를 가졌으므로  
adbd에서 d를 나눈 값을 만들 수 있는  
**A \* B / d**가 된다.

GCD = 7  
LCM = A \* B / 7

원래 A와 B의 약수들을 구하고  
비교해서 겹치는 약수끼리만 곱하는 작업을 한뒤에  
서로소를 곱해야 둘을 구할 수 있는데  
반복문 몇번만에 끝났으므로 더 효율적인 방법이다.
